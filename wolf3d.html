<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
<title>Neon Corridor Run</title>
<style>
*{box-sizing:border-box;margin:0;padding:0}
body{background:#03050c;font-family:'Space Grotesk',sans-serif;color:#fff;overflow:hidden}
canvas{display:block;width:100vw;height:100vh;background:#03050c}
#hud{position:absolute;top:18px;left:18px;display:flex;gap:24px;align-items:flex-start;font-size:14px;text-transform:uppercase;letter-spacing:1px;mix-blend-mode:screen}
#hud div{display:flex;flex-direction:column;font-weight:600}
#hud span{font-size:28px;letter-spacing:0;color:#f7f9ff;text-shadow:0 0 15px rgba(255,255,255,.7)}
#mini{position:absolute;top:18px;right:18px;border:1px solid rgba(255,255,255,.15);width:140px;height:140px;background:rgba(3,5,12,.6);border-radius:14px;backdrop-filter:blur(10px)}
#crosshair{position:absolute;top:50%;left:50%;width:34px;height:34px;margin:-17px 0 0 -17px;pointer-events:none;mix-blend-mode:screen}
#crosshair::before,#crosshair::after{content:"";position:absolute;background:linear-gradient(90deg,#0ff,#ff00ff);box-shadow:0 0 12px rgba(0,255,255,.7)}
#crosshair::before{width:34px;height:2px;top:16px;left:0}
#crosshair::after{width:2px;height:34px;left:16px;top:0}
#message{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);font-size:32px;text-align:center;text-shadow:0 0 20px #0ff;display:none}
#swipe-hint{position:absolute;bottom:26px;left:50%;transform:translateX(-50%);font-size:15px;letter-spacing:1px;text-transform:uppercase;color:#e0f7ff;text-shadow:0 0 10px rgba(0,255,255,.7);opacity:.85}
</style>
</head>
<body>
<canvas id="view"></canvas>
<canvas id="mini"></canvas>
<div id="hud">
  <div>Health<span id="health">100</span></div>
  <div>Ammo<span id="ammo">50</span></div>
  <div>Score<span id="score">0</span></div>
</div>
<div id="crosshair"></div>
<div id="swipe-hint">Swipe to steer Â· Tap to fire</div>
<div id="message"></div>
<script>
const canvas=document.getElementById('view');
const ctx=canvas.getContext('2d');
const mini=document.getElementById('mini');
const mctx=mini.getContext('2d');
let W,H,DPR=window.devicePixelRatio||1;
function resize(){W=canvas.width=innerWidth*DPR;H=canvas.height=innerHeight*DPR;canvas.style.width=innerWidth+'px';canvas.style.height=innerHeight+'px';ctx.imageSmoothingEnabled=false;mini.width=140*DPR;mini.height=140*DPR;mini.style.width='140px';mini.style.height='140px';}
resize();addEventListener('resize',resize);

const map=[
[1,1,1,1,1,1,1,1,1,1,1,1,1,1],
[1,0,0,0,0,0,0,0,0,2,0,0,0,1],
[1,0,3,0,3,0,3,0,0,0,0,2,0,1],
[1,0,0,0,0,0,0,0,0,0,0,0,0,1],
[1,0,0,4,0,4,0,4,0,0,0,0,0,1],
[1,0,0,0,0,0,0,0,0,3,0,0,0,1],
[1,0,2,0,2,0,2,0,2,0,0,0,0,1],
[1,0,0,0,0,0,0,0,0,0,0,4,0,1],
[1,0,0,0,3,0,0,0,0,0,0,0,0,1],
[1,0,0,0,0,0,0,0,0,0,0,0,0,1],
[1,1,1,1,1,1,1,1,1,1,1,1,1,1]
];
const MAP_W=map[0].length, MAP_H=map.length, TILE=64;

const player={x:2.5*TILE,y:5.5*TILE,angle:0,fov:Math.PI/2.8,speed:2.4,ammo:50,health:100,score:0};
const enemies=[{x:9.5*TILE,y:3.5*TILE,health:60,alive:true},{x:6.5*TILE,y:2.5*TILE,health:60,alive:true}];
const sparkles=[];

function isWall(x,y){const mx=Math.floor(x/TILE),my=Math.floor(y/TILE);return mx<0||my<0||mx>=MAP_W||my>=MAP_H||map[my][mx]>0;}

function castRay(angle,options={}){const sin=Math.sin(angle),cos=Math.cos(angle);let d=0;while(d<1500){const rx=player.x+cos*d,ry=player.y+sin*d;if(isWall(rx,ry)){const mx=Math.floor(rx/TILE),my=Math.floor(ry/TILE);return {dist:d,tex:map[my][mx],hx:rx,hy:ry};}if(options.enemy){for(const e of enemies){if(!e.alive)continue;if(Math.hypot(e.x-rx,e.y-ry)<22)return{dist:d,enemy:e};}}d+=5;}return null;}

function spawnHit(x,y){for(let i=0;i<14;i++){sparkles.push({x,y,vx:(Math.random()-0.5)*7,vy:(Math.random()-0.5)*7,life:1});}}

let lastShot=0;
function shoot(){const now=performance.now();if(now-lastShot<280||player.ammo<=0)return;player.ammo--;document.getElementById('ammo').textContent=player.ammo;lastShot=now;const hit=castRay(player.angle,{enemy:true});if(hit&&hit.enemy&&hit.dist<700){hit.enemy.health-=40;spawnHit(hit.enemy.x,hit.enemy.y);if(hit.enemy.health<=0){hit.enemy.alive=false;player.score+=400;document.getElementById('score').textContent=player.score;}}}

document.addEventListener('pointerdown',handlePointerDown);
document.addEventListener('pointermove',handlePointerMove);
document.addEventListener('pointerup',handlePointerUp);
document.addEventListener('pointercancel',handlePointerUp);
let pointerStart=null,swipeActive=false;
function handlePointerDown(e){pointerStart={x:e.clientX,y:e.clientY,time:performance.now()};swipeActive=true;}
function handlePointerMove(e){if(!swipeActive||!pointerStart)return;const dx=e.clientX-pointerStart.x;if(Math.abs(dx)>30){const turn=dx*0.0025;player.angle+=turn;pointerStart.x=e.clientX;}}
function handlePointerUp(e){if(!pointerStart)return;const dt=performance.now()-pointerStart.time;const dist=Math.hypot(e.clientX-pointerStart.x,e.clientY-pointerStart.y);if(dt<200&&dist<25)shoot();pointerStart=null;swipeActive=false;}

// desktop fallback (mouse movement)
let mouseDown=false;window.addEventListener('mousedown',()=>mouseDown=true);window.addEventListener('mouseup',()=>mouseDown=false);
window.addEventListener('mousemove',e=>{if(mouseDown&&!swipeActive){player.angle+=e.movementX*0.002;}if(mouseDown&&Math.abs(e.movementX)<2)shoot();});
document.addEventListener('keydown',e=>{if(e.code==='Space')shoot();});

function moveForward(){const cos=Math.cos(player.angle),sin=Math.sin(player.angle);let nx=player.x+cos*player.speed;let ny=player.y+sin*player.speed;if(!isWall(nx,player.y))player.x=nx;if(!isWall(player.x,ny))player.y=ny;}

function update(){moveForward();enemies.forEach(e=>{if(!e.alive)return;const dx=player.x-e.x,dy=player.y-e.y;const dist=Math.hypot(dx,dy);if(dist>200){e.x+=dx/dist*0.4;e.y+=dy/dist*0.4;}if(dist<80){player.health=Math.max(0,player.health-0.2);document.getElementById('health').textContent=player.health.toFixed(0);}});
for(let i=sparkles.length-1;i>=0;i--){const s=sparkles[i];s.x+=s.vx;s.y+=s.vy;s.vx*=0.9;s.vy*=0.9;s.life-=0.02;if(s.life<=0)sparkles.splice(i,1);} }

function render3D(){ctx.fillStyle='#03050c';ctx.fillRect(0,0,W,H);
const horizon=H/2;const grad=ctx.createLinearGradient(0,0,0,H);
grad.addColorStop(0,'rgba(5,10,30,0.7)');grad.addColorStop(0.45,'rgba(5,10,30,0.05)');grad.addColorStop(0.55,'rgba(2,4,8,0.05)');grad.addColorStop(1,'rgba(0,0,0,0.9)');
ctx.fillStyle=grad;ctx.fillRect(0,0,W,H);
const rays=W/1.2;
const angleStep=player.fov/rays;
for(let i=0;i<rays;i++){
  const angle=player.angle-player.fov/2+i*angleStep;
  const hit=castRay(angle);
  if(!hit)continue;
  const dist=hit.dist*Math.cos(angle-player.angle);
  const height=(TILE/dist)*(W/1.6);
  const x=i*(W/rays);
  const hue=hit.tex===1?210:hit.tex===2?320:hit.tex===3?45:140;
  const sat=85,light=55;
  const alpha=Math.max(0.15,1-dist/1200);
  const color=`hsla(${hue},${sat}%,${light}%,${alpha})`;
  ctx.fillStyle=color;
  ctx.fillRect(x,(horizon-height/2),W/rays+1,height);
  ctx.fillStyle=`rgba(0,0,0,${1-alpha})`;
  ctx.fillRect(x,(horizon-height/2),W/rays+1,height);
}
renderEnemies();renderSparkles();}

function renderEnemies(){enemies.forEach(enemy=>{if(!enemy.alive)return;const dx=enemy.x-player.x,dy=enemy.y-player.y;const dist=Math.hypot(dx,dy);const angle=Math.atan2(dy,dx)-player.angle;if(Math.abs(angle)>player.fov/1.7||dist<20)return;const size=Math.min(1200/dist,260);const screenX=W/2+Math.tan(angle)/(player.fov/2)*(W/2);const top=(H-size)/2;const gradient=ctx.createLinearGradient(screenX-size/2,top,screenX+size/2,top+size);
gradient.addColorStop(0,'rgba(130,255,255,.0)');gradient.addColorStop(0.5,'rgba(255,60,130,.95)');gradient.addColorStop(1,'rgba(40,5,15,.4)');ctx.fillStyle=gradient;ctx.fillRect(screenX-size/2,top,size,size*1.5);ctx.strokeStyle='rgba(255,255,255,.15)';ctx.strokeRect(screenX-size/2,top,size,size*1.5);} );}

function renderSparkles(){sparkles.forEach(s=>{const dx=s.x-player.x,dy=s.y-player.y;const dist=Math.hypot(dx,dy);const angle=Math.atan2(dy,dx)-player.angle;if(Math.abs(angle)>player.fov/1.5)return;const size=Math.min(400/dist,35);const screenX=W/2+Math.tan(angle)/(player.fov/2)*(W/2);const top=H/2-size/2;ctx.globalAlpha=s.life;ctx.fillStyle='#fffe80';ctx.fillRect(screenX-size/2,top,size,size);ctx.globalAlpha=1;});}

function renderMini(){mctx.clearRect(0,0,mini.width,mini.height);const scale=(mini.width/DPR)/MAP_W;
for(let y=0;y<MAP_H;y++)for(let x=0;x<MAP_W;x++)if(map[y][x]){mctx.fillStyle='rgba(0,255,255,.18)';mctx.fillRect(x*scale,y*scale,scale,scale);}
 mctx.fillStyle='#ff5aa5';enemies.forEach(e=>{if(e.alive)mctx.fillRect(e.x/TILE*scale-2,e.y/TILE*scale-2,4,4);});
 mctx.fillStyle='#00f7ff';mctx.beginPath();mctx.arc(player.x/TILE*scale,player.y/TILE*scale,4,0,Math.PI*2);mctx.fill();
 mctx.strokeStyle='rgba(255,255,255,.4)';mctx.beginPath();mctx.moveTo(player.x/TILE*scale,player.y/TILE*scale);mctx.lineTo(player.x/TILE*scale+Math.cos(player.angle)*12,player.y/TILE*scale+Math.sin(player.angle)*12);mctx.stroke();}

function loop(){requestAnimationFrame(loop);update();render3D();renderMini();}
loop();
</script>
</body>
</html>
